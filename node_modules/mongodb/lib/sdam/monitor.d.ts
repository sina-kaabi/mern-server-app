/// <reference types="node" />
import { Connection, ConnectionOptions } from '../cmap/connection';
import { CancellationToken, TypedEventEmitter } from '../mongo_types';
import type { InterruptibleAsyncInterval } from '../utils';
import { EventEmitterWithState } from '../utils';
import { ServerHeartbeatFailedEvent, ServerHeartbeatStartedEvent, ServerHeartbeatSucceededEvent } from './events';
import { Server } from './server';
/** @internal */
declare const kServer: unique symbol;
/** @internal */
declare const kMonitorId: unique symbol;
/** @internal */
declare const kConnection: unique symbol;
/** @internal */
declare const kCancellationToken: unique symbol;
/** @internal */
declare const kRTTPinger: unique symbol;
/** @internal */
declare const kRoundTripTime: unique symbol;
/** @internal */
export interface MonitorPrivate {
    state: string;
}
/** @public */
export interface MonitorOptions extends Omit<ConnectionOptions, 'id' | 'generation' | 'hostAddress'> {
    connectTimeoutMS: number;
    heartbeatFrequencyMS: number;
    minHeartbeatFrequencyMS: number;
}
/** @public */
export declare type MonitorEvents = {
    serverHeartbeatStarted(event: ServerHeartbeatStartedEvent): void;
    serverHeartbeatSucceeded(event: ServerHeartbeatSucceededEvent): void;
    serverHeartbeatFailed(event: ServerHeartbeatFailedEvent): void;
    resetServer(error?: Error): void;
    resetConnectionPool(): void;
    close(): void;
} & EventEmitterWithState;
/** @internal */
export declare class Monitor extends TypedEventEmitter<MonitorEvents> {
    /** @internal */
    s: MonitorPrivate;
    address: string;
    options: Readonly<Pick<MonitorOptions, 'connectTimeoutMS' | 'heartbeatFrequencyMS' | 'minHeartbeatFrequencyMS'>>;
    connectOptions: ConnectionOptions;
    [kServer]: Server;
    [kConnection]?: Connection;
    [kCancellationToken]: CancellationToken;
    /** @internal */
    [kMonitorId]?: InterruptibleAsyncInterval;
    [kRTTPinger]?: RTTPinger;
    constructor(server: Server, options: MonitorOptions);
    connect(): void;
    requestCheck(): void;
    reset(): void;
    close(): void;
}
/** @internal */
export interface RTTPingerOptions extends ConnectionOptions {
    heartbeatFrequencyMS: number;
}
/** @internal */
export declare class RTTPinger {
    /** @internal */
    [kConnection]?: Connection;
    /** @internal */
    [kCancellationToken]: CancellationToken;
    /** @internal */
    [kRoundTripTime]: number;
    /** @internal */
    [kMonitorId]: NodeJS.Timeout;
    closed: boolean;
    constructor(cancellationToken: CancellationToken, options: RTTPingerOptions);
    get roundTripTime(): number;
    close(): void;
}
export {};
//# sourceMappingURL=monitor.d.ts.map