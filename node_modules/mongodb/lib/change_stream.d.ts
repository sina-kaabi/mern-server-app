/// <reference types="node" />
import Denque = require('denque');
import type { Readable } from 'stream';
import type { Document, Long, Timestamp } from './bson';
import { Collection } from './collection';
import { AbstractCursor, AbstractCursorEvents, AbstractCursorOptions, CursorStreamOptions } from './cursor/abstract_cursor';
import { Db } from './db';
import { MongoClient } from './mongo_client';
import { InferIdType, TypedEventEmitter } from './mongo_types';
import { AggregateOptions } from './operations/aggregate';
import type { CollationOptions, OperationParent } from './operations/command';
import { ExecutionResult } from './operations/execute_operation';
import type { ReadPreference } from './read_preference';
import type { Topology } from './sdam/topology';
import type { ClientSession, ServerSessionId } from './sessions';
import { Callback, MongoDBNamespace } from './utils';
/** @internal */
declare const kResumeQueue: unique symbol;
/** @internal */
declare const kCursorStream: unique symbol;
/** @internal */
declare const kClosed: unique symbol;
/** @internal */
declare const kMode: unique symbol;
/** @public */
export interface ResumeOptions {
    startAtOperationTime?: Timestamp;
    batchSize?: number;
    maxAwaitTimeMS?: number;
    collation?: CollationOptions;
    readPreference?: ReadPreference;
    resumeAfter?: ResumeToken;
    startAfter?: ResumeToken;
}
/**
 * Represents the logical starting point for a new ChangeStream or resuming a ChangeStream on the server.
 * @see https://www.mongodb.com/docs/manual/changeStreams/#std-label-change-stream-resume
 * @public
 */
export declare type ResumeToken = unknown;
/**
 * Represents a specific point in time on a server. Can be retrieved by using `db.command()`
 * @public
 * @see https://docs.mongodb.com/manual/reference/method/db.runCommand/#response
 */
export declare type OperationTime = Timestamp;
/** @public */
export interface PipeOptions {
    end?: boolean;
}
/** @internal */
export declare type ChangeStreamAggregateRawResult<TChange> = {
    $clusterTime: {
        clusterTime: Timestamp;
    };
    cursor: {
        postBatchResumeToken: ResumeToken;
        ns: string;
        id: number | Long;
    } & ({
        firstBatch: TChange[];
    } | {
        nextBatch: TChange[];
    });
    ok: 1;
    operationTime: Timestamp;
};
/**
 * Options that can be passed to a ChangeStream. Note that startAfter, resumeAfter, and startAtOperationTime are all mutually exclusive, and the server will error if more than one is specified.
 * @public
 */
export interface ChangeStreamOptions extends AggregateOptions {
    /**
     * Allowed values: 'updateLookup'. When set to 'updateLookup',
     * the change stream will include both a delta describing the changes to the document,
     * as well as a copy of the entire document that was changed from some time after the change occurred.
     */
    fullDocument?: string;
    /** The maximum amount of time for the server to wait on new documents to satisfy a change stream query. */
    maxAwaitTimeMS?: number;
    /**
     * Allows you to start a changeStream after a specified event.
     * @see https://docs.mongodb.com/manual/changeStreams/#resumeafter-for-change-streams
     */
    resumeAfter?: ResumeToken;
    /**
     * Similar to resumeAfter, but will allow you to start after an invalidated event.
     * @see https://docs.mongodb.com/manual/changeStreams/#startafter-for-change-streams
     */
    startAfter?: ResumeToken;
    /** Will start the changeStream after the specified operationTime. */
    startAtOperationTime?: OperationTime;
    /**
     * The number of documents to return per batch.
     * @see https://docs.mongodb.com/manual/reference/command/aggregate
     */
    batchSize?: number;
}
/** @public */
export interface ChangeStreamNameSpace {
    db: string;
    coll: string;
}
/** @public */
export interface ChangeStreamDocumentKey<TSchema extends Document = Document> {
    /**
     * For unsharded collections this contains a single field `_id`.
     * For sharded collections, this will contain all the components of the shard key
     */
    documentKey: {
        _id: InferIdType<TSchema>;
        [shardKey: string]: any;
    };
}
/** @public */
export interface ChangeStreamDocumentCommon {
    /**
     * The id functions as an opaque token for use when resuming an interrupted
     * change stream.
     */
    _id: ResumeToken;
    /**
     * The timestamp from the oplog entry associated with the event.
     * For events that happened as part of a multi-document transaction, the associated change stream
     * notifications will have the same clusterTime value, namely the time when the transaction was committed.
     * On a sharded cluster, events that occur on different shards can have the same clusterTime but be
     * associated with different transactions or even not be associated with any transaction.
     * To identify events for a single transaction, you can use the combination of lsid and txnNumber in the change stream event document.
     */
    clusterTime?: Timestamp;
    /**
     * The transaction number.
     * Only present if the operation is part of a multi-document transaction.
     *
     * **NOTE:** txnNumber can be a Long if promoteLongs is set to false
     */
    txnNumber?: number;
    /**
     * The identifier for the session associated with the transaction.
     * Only present if the operation is part of a multi-document transaction.
     */
    lsid?: ServerSessionId;
}
/**
 * @public
 * @see https://www.mongodb.com/docs/manual/reference/change-events/#insert-event
 */
export interface ChangeStreamInsertDocument<TSchema extends Document = Document> extends ChangeStreamDocumentCommon, ChangeStreamDocumentKey<TSchema> {
    /** Describes the type of operation represented in this change notification */
    operationType: 'insert';
    /** This key will contain the document being inserted */
    fullDocument: TSchema;
    /** Namespace the insert event occured on */
    ns: ChangeStreamNameSpace;
}
/**
 * @public
 * @see https://www.mongodb.com/docs/manual/reference/change-events/#update-event
 */
export interface ChangeStreamUpdateDocument<TSchema extends Document = Document> extends ChangeStreamDocumentCommon, ChangeStreamDocumentKey<TSchema> {
    /** Describes the type of operation represented in this change notification */
    operationType: 'update';
    /**
     * This is only set if `fullDocument` is set to `'updateLookup'`
     * The fullDocument document represents the most current majority-committed version of the updated document.
     * The fullDocument document may vary from the document at the time of the update operation depending on the
     * number of interleaving majority-committed operations that occur between the update operation and the document lookup.
     */
    fullDocument?: TSchema;
    /** Contains a description of updated and removed fields in this operation */
    updateDescription: UpdateDescription<TSchema>;
    /** Namespace the update event occured on */
    ns: ChangeStreamNameSpace;
}
/**
 * @public
 * @see https://www.mongodb.com/docs/manual/reference/change-events/#replace-event
 */
export interface ChangeStreamReplaceDocument<TSchema extends Document = Document> extends ChangeStreamDocumentCommon, ChangeStreamDocumentKey<TSchema> {
    /** Describes the type of operation represented in this change notification */
    operationType: 'replace';
    /** The fullDocument of a replace event represents the document after the insert of the replacement document */
    fullDocument: TSchema;
    /** Namespace the replace event occured on */
    ns: ChangeStreamNameSpace;
}
/**
 * @public
 * @see https://www.mongodb.com/docs/manual/reference/change-events/#delete-event
 */
export interface ChangeStreamDeleteDocument<TSchema extends Document = Document> extends ChangeStreamDocumentCommon, ChangeStreamDocumentKey<TSchema> {
    /** Describes the type of operation represented in this change notification */
    operationType: 'delete';
    /** Namespace the delete event occured on */
    ns: ChangeStreamNameSpace;
}
/**
 * @public
 * @see https://www.mongodb.com/docs/manual/reference/change-events/#drop-event
 */
export interface ChangeStreamDropDocument extends ChangeStreamDocumentCommon {
    /** Describes the type of operation represented in this change notification */
    operationType: 'drop';
    /** Namespace the drop event occured on */
    ns: ChangeStreamNameSpace;
}
/**
 * @public
 * @see https://www.mongodb.com/docs/manual/reference/change-events/#rename-event
 */
export interface ChangeStreamRenameDocument extends ChangeStreamDocumentCommon {
    /** Describes the type of operation represented in this change notification */
    operationType: 'rename';
    /** The new name for the `ns.coll` collection */
    to: {
        db: string;
        coll: string;
    };
    /** The "from" namespace that the rename occured on */
    ns: ChangeStreamNameSpace;
}
/**
 * @public
 * @see https://www.mongodb.com/docs/manual/reference/change-events/#dropdatabase-event
 */
export interface ChangeStreamDropDatabaseDocument extends ChangeStreamDocumentCommon {
    /** Describes the type of operation represented in this change notification */
    operationType: 'dropDatabase';
    /** The database dropped */
    ns: {
        db: string;
    };
}
/**
 * @public
 * @see https://www.mongodb.com/docs/manual/reference/change-events/#invalidate-event
 */
export interface ChangeStreamInvalidateDocument extends ChangeStreamDocumentCommon {
    /** Describes the type of operation represented in this change notification */
    operationType: 'invalidate';
}
/** @public */
export declare type ChangeStreamDocument<TSchema extends Document = Document> = ChangeStreamInsertDocument<TSchema> | ChangeStreamUpdateDocument<TSchema> | ChangeStreamReplaceDocument<TSchema> | ChangeStreamDeleteDocument<TSchema> | ChangeStreamDropDocument | ChangeStreamRenameDocument | ChangeStreamDropDatabaseDocument | ChangeStreamInvalidateDocument;
/** @public */
export interface UpdateDescription<TSchema extends Document = Document> {
    /**
     * A document containing key:value pairs of names of the fields that were
     * changed, and the new value for those fields.
     */
    updatedFields?: Partial<TSchema>;
    /**
     * An array of field names that were removed from the document.
     */
    removedFields?: string[];
    /**
     * An array of documents which record array truncations performed with pipeline-based updates using one or more of the following stages:
     * - $addFields
     * - $set
     * - $replaceRoot
     * - $replaceWith
     */
    truncatedArrays?: Array<{
        /** The name of the truncated field. */
        field: string;
        /** The number of elements in the truncated array. */
        newSize: number;
    }>;
}
/** @public */
export declare type ChangeStreamEvents<TSchema extends Document = Document, TChange extends Document = ChangeStreamDocument<TSchema>> = {
    resumeTokenChanged(token: ResumeToken): void;
    init(response: any): void;
    more(response?: any): void;
    response(): void;
    end(): void;
    error(error: Error): void;
    change(change: TChange): void;
} & AbstractCursorEvents;
/**
 * Creates a new Change Stream instance. Normally created using {@link Collection#watch|Collection.watch()}.
 * @public
 */
export declare class ChangeStream<TSchema extends Document = Document, TChange extends Document = ChangeStreamDocument<TSchema>> extends TypedEventEmitter<ChangeStreamEvents<TSchema, TChange>> {
    pipeline: Document[];
    options: ChangeStreamOptions;
    parent: MongoClient | Db | Collection;
    namespace: MongoDBNamespace;
    type: symbol;
    /** @internal */
    cursor: ChangeStreamCursor<TSchema, TChange> | undefined;
    streamOptions?: CursorStreamOptions;
    /** @internal */
    [kResumeQueue]: Denque<Callback<ChangeStreamCursor<TSchema, TChange>>>;
    /** @internal */
    [kCursorStream]?: Readable & AsyncIterable<TChange>;
    /** @internal */
    [kClosed]: boolean;
    /** @internal */
    [kMode]: false | 'iterator' | 'emitter';
    /** @event */
    static readonly RESPONSE: "response";
    /** @event */
    static readonly MORE: "more";
    /** @event */
    static readonly INIT: "init";
    /** @event */
    static readonly CLOSE: "close";
    /**
     * Fired for each new matching change in the specified namespace. Attaching a `change`
     * event listener to a Change Stream will switch the stream into flowing mode. Data will
     * then be passed as soon as it is available.
     * @event
     */
    static readonly CHANGE: "change";
    /** @event */
    static readonly END: "end";
    /** @event */
    static readonly ERROR: "error";
    /**
     * Emitted each time the change stream stores a new resume token.
     * @event
     */
    static readonly RESUME_TOKEN_CHANGED: "resumeTokenChanged";
    /**
     * @internal
     *
     * @param parent - The parent object that created this change stream
     * @param pipeline - An array of {@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline/|aggregation pipeline stages} through which to pass change stream documents
     */
    constructor(parent: OperationParent, pipeline?: Document[], options?: ChangeStreamOptions);
    /** @internal */
    get cursorStream(): (Readable & AsyncIterable<TChange>) | undefined;
    /** The cached resume token that is used to resume after the most recently returned change. */
    get resumeToken(): ResumeToken;
    /** Check if there is any document still available in the Change Stream */
    hasNext(): Promise<boolean>;
    hasNext(callback: Callback<boolean>): void;
    /** Get the next available document from the Change Stream. */
    next(): Promise<TChange>;
    next(callback: Callback<TChange>): void;
    /** Is the cursor closed */
    get closed(): boolean;
    /** Close the Change Stream */
    close(callback?: Callback): Promise<void> | void;
    /**
     * Return a modified Readable stream including a possible transform method.
     * @throws MongoDriverError if this.cursor is undefined
     */
    stream(options?: CursorStreamOptions): Readable & AsyncIterable<TChange>;
    /**
     * Try to get the next available document from the Change Stream's cursor or `null` if an empty batch is returned
     */
    tryNext(): Promise<Document | null>;
    tryNext(callback: Callback<Document | null>): void;
    /** @internal */
    private _setIsEmitter;
    /** @internal */
    private _setIsIterator;
    /**
     * Create a new change stream cursor based on self's configuration
     * @internal
     */
    private _createChangeStreamCursor;
    /**
     * This method performs a basic server selection loop, satisfying the requirements of
     * ChangeStream resumability until the new SDAM layer can be used.
     * @internal
     */
    private _waitForTopologyConnected;
    /** @internal */
    private _closeWithError;
    /** @internal */
    private _streamEvents;
    /** @internal */
    private _endStream;
    /** @internal */
    private _processNewChange;
    /** @internal */
    private _processError;
    /** @internal */
    private _getCursor;
    /**
     * Drain the resume queue when a new has become available
     * @internal
     *
     * @param err - error getting a new cursor
     */
    private _processResumeQueue;
}
/** @internal */
export interface ChangeStreamCursorOptions extends AbstractCursorOptions {
    startAtOperationTime?: OperationTime;
    resumeAfter?: ResumeToken;
    startAfter?: ResumeToken;
}
/** @internal */
export declare class ChangeStreamCursor<TSchema extends Document = Document, TChange extends Document = ChangeStreamDocument<TSchema>> extends AbstractCursor<TChange, ChangeStreamEvents> {
    _resumeToken: ResumeToken;
    startAtOperationTime?: OperationTime;
    hasReceived?: boolean;
    resumeAfter: ResumeToken;
    startAfter: ResumeToken;
    options: ChangeStreamCursorOptions;
    postBatchResumeToken?: ResumeToken;
    pipeline: Document[];
    constructor(topology: Topology, namespace: MongoDBNamespace, pipeline?: Document[], options?: ChangeStreamCursorOptions);
    set resumeToken(token: ResumeToken);
    get resumeToken(): ResumeToken;
    get resumeOptions(): ResumeOptions;
    cacheResumeToken(resumeToken: ResumeToken): void;
    _processBatch(response: ChangeStreamAggregateRawResult<TChange>): void;
    clone(): AbstractCursor<TChange>;
    _initialize(session: ClientSession, callback: Callback<ExecutionResult>): void;
    _getMore(batchSize: number, callback: Callback): void;
}
export {};
//# sourceMappingURL=change_stream.d.ts.map