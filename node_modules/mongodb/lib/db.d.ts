import { Admin } from './admin';
import { BSONSerializeOptions, Document } from './bson';
import { ChangeStream, ChangeStreamDocument, ChangeStreamOptions } from './change_stream';
import { Collection, CollectionOptions } from './collection';
import { AggregationCursor } from './cursor/aggregation_cursor';
import { Logger, LoggerOptions } from './logger';
import type { MongoClient, PkFactory } from './mongo_client';
import { AddUserOptions } from './operations/add_user';
import type { AggregateOptions } from './operations/aggregate';
import type { IndexInformationOptions } from './operations/common_functions';
import { CreateCollectionOptions } from './operations/create_collection';
import { DropCollectionOptions, DropDatabaseOptions } from './operations/drop';
import { CreateIndexesOptions, IndexSpecification } from './operations/indexes';
import { CollectionInfo, ListCollectionsCursor, ListCollectionsOptions } from './operations/list_collections';
import { ProfilingLevelOptions } from './operations/profiling_level';
import { RemoveUserOptions } from './operations/remove_user';
import { RenameOptions } from './operations/rename';
import { RunCommandOptions } from './operations/run_command';
import { ProfilingLevel, SetProfilingLevelOptions } from './operations/set_profiling_level';
import { DbStatsOptions } from './operations/stats';
import { ReadConcern } from './read_concern';
import { ReadPreference, ReadPreferenceLike } from './read_preference';
import { Callback, MongoDBNamespace } from './utils';
import { WriteConcern, WriteConcernOptions } from './write_concern';
/** @internal */
export interface DbPrivate {
    client: MongoClient;
    options?: DbOptions;
    logger: Logger;
    readPreference?: ReadPreference;
    pkFactory: PkFactory;
    readConcern?: ReadConcern;
    bsonOptions: BSONSerializeOptions;
    writeConcern?: WriteConcern;
    namespace: MongoDBNamespace;
}
/** @public */
export interface DbOptions extends BSONSerializeOptions, WriteConcernOptions, LoggerOptions {
    /** If the database authentication is dependent on another databaseName. */
    authSource?: string;
    /** Force server to assign _id values instead of driver. */
    forceServerObjectId?: boolean;
    /** The preferred read preference (ReadPreference.PRIMARY, ReadPreference.PRIMARY_PREFERRED, ReadPreference.SECONDARY, ReadPreference.SECONDARY_PREFERRED, ReadPreference.NEAREST). */
    readPreference?: ReadPreferenceLike;
    /** A primary key factory object for generation of custom _id keys. */
    pkFactory?: PkFactory;
    /** Specify a read concern for the collection. (only MongoDB 3.2 or higher supported) */
    readConcern?: ReadConcern;
    /** Should retry failed writes */
    retryWrites?: boolean;
}
/**
 * The **Db** class is a class that represents a MongoDB Database.
 * @public
 *
 * @example
 * ```js
 * const { MongoClient } = require('mongodb');
 * // Connection url
 * const url = 'mongodb://localhost:27017';
 * // Database Name
 * const dbName = 'test';
 * // Connect using MongoClient
 * MongoClient.connect(url, function(err, client) {
 *   // Select the database by name
 *   const testDb = client.db(dbName);
 *   client.close();
 * });
 * ```
 */
export declare class Db {
    /** @internal */
    s: DbPrivate;
    static SYSTEM_NAMESPACE_COLLECTION: string;
    static SYSTEM_INDEX_COLLECTION: string;
    static SYSTEM_PROFILE_COLLECTION: string;
    static SYSTEM_USER_COLLECTION: string;
    static SYSTEM_COMMAND_COLLECTION: string;
    static SYSTEM_JS_COLLECTION: string;
    /**
     * Creates a new Db instance
     *
     * @param client - The MongoClient for the database.
     * @param databaseName - The name of the database this instance represents.
     * @param options - Optional settings for Db construction
     */
    constructor(client: MongoClient, databaseName: string, options?: DbOptions);
    get databaseName(): string;
    get options(): DbOptions | undefined;
    /**
     * slaveOk specified
     * @deprecated Use secondaryOk instead
     */
    get slaveOk(): boolean;
    /**
     * Check if a secondary can be used (because the read preference is *not* set to primary)
     */
    get secondaryOk(): boolean;
    get readConcern(): ReadConcern | undefined;
    /**
     * The current readPreference of the Db. If not explicitly defined for
     * this Db, will be inherited from the parent MongoClient
     */
    get readPreference(): ReadPreference;
    get bsonOptions(): BSONSerializeOptions;
    get writeConcern(): WriteConcern | undefined;
    get namespace(): string;
    /**
     * Create a new collection on a server with the specified options. Use this to create capped collections.
     * More information about command options available at https://docs.mongodb.com/manual/reference/command/create/
     *
     * @param name - The name of the collection to create
     * @param options - Optional settings for the command
     * @param callback - An optional callback, a Promise will be returned if none is provided
     */
    createCollection<TSchema extends Document = Document>(name: string, options?: CreateCollectionOptions): Promise<Collection<TSchema>>;
    createCollection<TSchema extends Document = Document>(name: string, callback: Callback<Collection<TSchema>>): void;
    createCollection<TSchema extends Document = Document>(name: string, options: CreateCollectionOptions | undefined, callback: Callback<Collection<TSchema>>): void;
    /**
     * Execute a command
     *
     * @remarks
     * This command does not inherit options from the MongoClient.
     *
     * @param command - The command to run
     * @param options - Optional settings for the command
     * @param callback - An optional callback, a Promise will be returned if none is provided
     */
    command(command: Document): Promise<Document>;
    command(command: Document, callback: Callback<Document>): void;
    command(command: Document, options: RunCommandOptions): Promise<Document>;
    command(command: Document, options: RunCommandOptions, callback: Callback<Document>): void;
    /**
     * Execute an aggregation framework pipeline against the database, needs MongoDB \>= 3.6
     *
     * @param pipeline - An array of aggregation stages to be executed
     * @param options - Optional settings for the command
     */
    aggregate<T extends Document = Document>(pipeline?: Document[], options?: AggregateOptions): AggregationCursor<T>;
    /** Return the Admin db instance */
    admin(): Admin;
    /**
     * Returns a reference to a MongoDB Collection. If it does not exist it will be created implicitly.
     *
     * @param name - the collection name we wish to access.
     * @returns return the new Collection instance
     */
    collection<TSchema extends Document = Document>(name: string, options?: CollectionOptions): Collection<TSchema>;
    /**
     * Get all the db statistics.
     *
     * @param options - Optional settings for the command
     * @param callback - An optional callback, a Promise will be returned if none is provided
     */
    stats(): Promise<Document>;
    stats(callback: Callback<Document>): void;
    stats(options: DbStatsOptions): Promise<Document>;
    stats(options: DbStatsOptions, callback: Callback<Document>): void;
    /**
     * List all collections of this database with optional filter
     *
     * @param filter - Query to filter collections by
     * @param options - Optional settings for the command
     */
    listCollections(filter: Document, options: Exclude<ListCollectionsOptions, 'nameOnly'> & {
        nameOnly: true;
    }): ListCollectionsCursor<Pick<CollectionInfo, 'name' | 'type'>>;
    listCollections(filter: Document, options: Exclude<ListCollectionsOptions, 'nameOnly'> & {
        nameOnly: false;
    }): ListCollectionsCursor<CollectionInfo>;
    listCollections<T extends Pick<CollectionInfo, 'name' | 'type'> | CollectionInfo = Pick<CollectionInfo, 'name' | 'type'> | CollectionInfo>(filter?: Document, options?: ListCollectionsOptions): ListCollectionsCursor<T>;
    /**
     * Rename a collection.
     *
     * @remarks
     * This operation does not inherit options from the MongoClient.
     *
     * @param fromCollection - Name of current collection to rename
     * @param toCollection - New name of of the collection
     * @param options - Optional settings for the command
     * @param callback - An optional callback, a Promise will be returned if none is provided
     */
    renameCollection<TSchema extends Document = Document>(fromCollection: string, toCollection: string): Promise<Collection<TSchema>>;
    renameCollection<TSchema extends Document = Document>(fromCollection: string, toCollection: string, callback: Callback<Collection<TSchema>>): void;
    renameCollection<TSchema extends Document = Document>(fromCollection: string, toCollection: string, options: RenameOptions): Promise<Collection<TSchema>>;
    renameCollection<TSchema extends Document = Document>(fromCollection: string, toCollection: string, options: RenameOptions, callback: Callback<Collection<TSchema>>): void;
    /**
     * Drop a collection from the database, removing it permanently. New accesses will create a new collection.
     *
     * @param name - Name of collection to drop
     * @param options - Optional settings for the command
     * @param callback - An optional callback, a Promise will be returned if none is provided
     */
    dropCollection(name: string): Promise<boolean>;
    dropCollection(name: string, callback: Callback<boolean>): void;
    dropCollection(name: string, options: DropCollectionOptions): Promise<boolean>;
    dropCollection(name: string, options: DropCollectionOptions, callback: Callback<boolean>): void;
    /**
     * Drop a database, removing it permanently from the server.
     *
     * @param options - Optional settings for the command
     * @param callback - An optional callback, a Promise will be returned if none is provided
     */
    dropDatabase(): Promise<boolean>;
    dropDatabase(callback: Callback<boolean>): void;
    dropDatabase(options: DropDatabaseOptions): Promise<boolean>;
    dropDatabase(options: DropDatabaseOptions, callback: Callback<boolean>): void;
    /**
     * Fetch all collections for the current db.
     *
     * @param options - Optional settings for the command
     * @param callback - An optional callback, a Promise will be returned if none is provided
     */
    collections(): Promise<Collection[]>;
    collections(callback: Callback<Collection[]>): void;
    collections(options: ListCollectionsOptions): Promise<Collection[]>;
    collections(options: ListCollectionsOptions, callback: Callback<Collection[]>): void;
    /**
     * Creates an index on the db and collection.
     *
     * @param name - Name of the collection to create the index on.
     * @param indexSpec - Specify the field to index, or an index specification
     * @param options - Optional settings for the command
     * @param callback - An optional callback, a Promise will be returned if none is provided
     */
    createIndex(name: string, indexSpec: IndexSpecification): Promise<string>;
    createIndex(name: string, indexSpec: IndexSpecification, callback?: Callback<string>): void;
    createIndex(name: string, indexSpec: IndexSpecification, options: CreateIndexesOptions): Promise<string>;
    createIndex(name: string, indexSpec: IndexSpecification, options: CreateIndexesOptions, callback: Callback<string>): void;
    /**
     * Add a user to the database
     *
     * @param username - The username for the new user
     * @param password - An optional password for the new user
     * @param options - Optional settings for the command
     * @param callback - An optional callback, a Promise will be returned if none is provided
     */
    addUser(username: string): Promise<Document>;
    addUser(username: string, callback: Callback<Document>): void;
    addUser(username: string, password: string): Promise<Document>;
    addUser(username: string, password: string, callback: Callback<Document>): void;
    addUser(username: string, options: AddUserOptions): Promise<Document>;
    addUser(username: string, options: AddUserOptions, callback: Callback<Document>): void;
    addUser(username: string, password: string, options: AddUserOptions): Promise<Document>;
    addUser(username: string, password: string, options: AddUserOptions, callback: Callback<Document>): void;
    /**
     * Remove a user from a database
     *
     * @param username - The username to remove
     * @param options - Optional settings for the command
     * @param callback - An optional callback, a Promise will be returned if none is provided
     */
    removeUser(username: string): Promise<boolean>;
    removeUser(username: string, callback: Callback<boolean>): void;
    removeUser(username: string, options: RemoveUserOptions): Promise<boolean>;
    removeUser(username: string, options: RemoveUserOptions, callback: Callback<boolean>): void;
    /**
     * Set the current profiling level of MongoDB
     *
     * @param level - The new profiling level (off, slow_only, all).
     * @param options - Optional settings for the command
     * @param callback - An optional callback, a Promise will be returned if none is provided
     */
    setProfilingLevel(level: ProfilingLevel): Promise<ProfilingLevel>;
    setProfilingLevel(level: ProfilingLevel, callback: Callback<ProfilingLevel>): void;
    setProfilingLevel(level: ProfilingLevel, options: SetProfilingLevelOptions): Promise<ProfilingLevel>;
    setProfilingLevel(level: ProfilingLevel, options: SetProfilingLevelOptions, callback: Callback<ProfilingLevel>): void;
    /**
     * Retrieve the current profiling Level for MongoDB
     *
     * @param options - Optional settings for the command
     * @param callback - An optional callback, a Promise will be returned if none is provided
     */
    profilingLevel(): Promise<string>;
    profilingLevel(callback: Callback<string>): void;
    profilingLevel(options: ProfilingLevelOptions): Promise<string>;
    profilingLevel(options: ProfilingLevelOptions, callback: Callback<string>): void;
    /**
     * Retrieves this collections index info.
     *
     * @param name - The name of the collection.
     * @param options - Optional settings for the command
     * @param callback - An optional callback, a Promise will be returned if none is provided
     */
    indexInformation(name: string): Promise<Document>;
    indexInformation(name: string, callback: Callback<Document>): void;
    indexInformation(name: string, options: IndexInformationOptions): Promise<Document>;
    indexInformation(name: string, options: IndexInformationOptions, callback: Callback<Document>): void;
    /**
     * Unref all sockets
     * @deprecated This function is deprecated and will be removed in the next major version.
     */
    unref(): void;
    /**
     * Create a new Change Stream, watching for new changes (insertions, updates,
     * replacements, deletions, and invalidations) in this database. Will ignore all
     * changes to system collections.
     *
     * @remarks
     * watch() accepts two generic arguments for distinct usecases:
     * - The first is to provide the schema that may be defined for all the collections within this database
     * - The second is to override the shape of the change stream document entirely, if it is not provided the type will default to ChangeStreamDocument of the first argument
     *
     * @param pipeline - An array of {@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline/|aggregation pipeline stages} through which to pass change stream documents. This allows for filtering (using $match) and manipulating the change stream documents.
     * @param options - Optional settings for the command
     * @typeParam TSchema - Type of the data being detected by the change stream
     * @typeParam TChange - Type of the whole change stream document emitted
     */
    watch<TSchema extends Document = Document, TChange extends Document = ChangeStreamDocument<TSchema>>(pipeline?: Document[], options?: ChangeStreamOptions): ChangeStream<TSchema, TChange>;
    /** Return the db logger */
    getLogger(): Logger;
    get logger(): Logger;
}
//# sourceMappingURL=db.d.ts.map